\chapter{Query Evaluation Results and Discussion}\label{results}
To analyse the functionality of the database systems, I devised a number of queries with ranging difficulties. The aim of the queries was to identify any limitations of the systems, and to discover the efficacy of the systems. Chapter \ref{evaluationstrategy} provides a detailed explanation of the reasoning behind the queries and this chapter discusses the output and results of running the queries in the various query languages. This chapter gives insight into the difficulty of writing the query, the usefulness of the output, the time taken for the query to run and any challenges I faced when actioning the evaluation strategy. Also included in this chapter is a general discussion which summarises the capabilities of the systems and aims to provide one with an understanding of the limitations of each of the systems, section  \ref{discussion}.

\section{Query Output}\label{output}
The screenshots, tables, graphs and charts illustrated in this chapter are based on the results of running the competency based queries on each database system. Table \ref{tab:competency} details each of the devised queries in English, provides a short description of the data expected to be returned and a rating characterisation. Each query has a rating with a range of 1 to 5, and is to be used as a guide to aid the reader into understanding \textbf{1.} General complexity of the query. \textbf{2.} Fruitfulness of the data returned. \textbf{3.} Level of expectancy that the system will be able to accomplish the query (on a scale of 1 expected, to 5 unexpected).

\newpage
\begin{table}[H]
\centering
\resizebox{\textwidth}{!}{
\begin{tabular}{|c|l|l|c|}
\hline
\textbf{Query Number} & \multicolumn{1}{c|}{\textbf{English}} & \multicolumn{1}{c|}{\textbf{Expected return}} & \textbf{Rating} \\ \hline
1 & All structures at Theiler Stage X. & Theiler Stage. Structure ID. & 1 \\ \hline
2 & \begin{tabular}[c]{@{}l@{}}All structures between Theiler\\ Stage X and Y.\end{tabular} & \begin{tabular}[c]{@{}l@{}}Structure ID. Theiler Stage X. Theiler Stage\\ Y.\end{tabular} & 1 \\ \hline
3 & Where is Gene X expressed? & \begin{tabular}[c]{@{}l@{}}Name of the gene. The structure where the\\ gene was found. The EMAGE ID where the\\ gene was found.\end{tabular} & 2 \\ \hline
4 & What is expressed in structure X? & \begin{tabular}[c]{@{}l@{}}Name of the gene(s) found in the structure.\\ The structure ID. The name of the structure.\\ The Theiler Stage(s) of the structure. The\\ EMAGE ID of the structure.\end{tabular} & 3 \\ \hline
5 & \begin{tabular}[c]{@{}l@{}}Which genes are stored in\\ structures X and Y?\end{tabular} & \begin{tabular}[c]{@{}l@{}}Name of the gene(s). ID of the gene(s). ID\\ of structure X. ID of structure Y.\end{tabular} & 4 \\ \hline
6 & \begin{tabular}[c]{@{}l@{}}Which Genes are most\\ commonly co-expressed?\end{tabular} & \begin{tabular}[c]{@{}l@{}}Name of the gene(s). Count of unique\\ structures the gene is expressed in.\end{tabular} & 5 \\ \hline
7 & Calculate transitive closure. & The name of each structure and its parent. & 5 \\ \hline
\end{tabular}
}
\caption{Competency questions to query each database system.}
\label{tab:competency}
\end{table}

\subsection*{Query 1 - All structures at Theiler Stage X}\label{query1}

The following code snippets represent the queries written for competency question 1.
\begin{itemize}
\item \textbf{MySQL}
\begin{lstlisting}[language=SQL, caption=, label=code:mysqlload]
SELECT t1.accession AS StructureID, t1.term AS StructureName, t2.theilerstage AS TheilerStage, t2.dpc AS DPC
FROM AnatomyStructures AS t1
INNER JOIN Stages AS t2
ON t1.stage_id = t2.id
WHERE t2.theilerstage = 4
ORDER BY 1
\end{lstlisting}
\end{itemize}
\parindent 15pt
\section{Discussion}\label{discussion}
Intuitively, one would expect quicker load times and a slower querying performance with no implemented indexes. Figure \ref{fig:index} clearly illustrates that the time taken to load the data without index keys and constraints had little, to no true affect on load performance. While there is slight variance in load time, this can be expected and attributed to a number of reasons, such as other processes running simultaneously on the CPU for example.